 	$( document ).ready(function() {
 		if(viewer!=undefined){
			var options = [];					
			$.each(dataSourceLayers, function(k,v){
				options.push('<option value=\''+v+'\'>'+v+'</option>');
			});
			$('#layers').html(options);
			$('#layers').selectpicker('refresh');
			$('#layers').val(dataSourceLayers);
			$('#layers').selectpicker('refresh');
			showMouseCartographicPosition();
		}
	});
	
	var dataSourceLayers = [];
	
	$('#layers').on('change', function(){
		var datasources = dataSourceLayers;
		var imageryLayers = viewer.imageryLayers._layers;
		var dataSourcesViewer = viewer.dataSources._dataSources;
		var layersSelected = $('#layers').val();
		var options = [];
		var layers = [];
								
		$.each(datasources, function(k,v){
			var layer = v;
			var dataSourceLayer = 'dataSource' + v;
			if(layersSelected.includes(layer)){
				options.push('<option value=\''+layer+'\'>'+layer+'</option>');
				layers.push(layer);
				$.each(dataSourcesViewer, function(index, value){
					if(value.name.name == 'dataSource' + layer || value.name == 'dataSource' + layer){
						value.show = true;
					}
				});
				
				$.each(imageryLayers, function(index, value){
					if(value.imageryProvider.name == 'dataSource' + layer){
						value.show = true;
					}
				});
				
				$.each(heatMapLayers, function(index,value){
					if(value.layer == layer){
						value.heatMap._layer.show=true;
					}
				});
				
			}else{
				$.each(dataSourcesViewer, function(index, value){
					if(value.name.name == 'dataSource'  + layer || value.name == 'dataSource' + layer){
						value.show = false;
					}
				});
				
				$.each(imageryLayers, function(index, value){
					if(value.imageryProvider.name == 'dataSource'  + layer){
						value.show = false;
					}
				});
				
				$.each(heatMapLayers, function(index,value){
					if(value.layer == layer){
						value.heatMap._layer.show=false;
					}
				});
			}
			
		});
		
		$('#layers').val(layers);
		$('#layers').selectpicker('refresh');
	});
 
 /** Variables con la extensión inicial del mapa y su altura/zoom */
	  var initialLongitude = -15.4340
	  var initialLatitude = 28.1340
	
	  var initialHeight = 4500
	  var initialZoom = 15
	
	
	  /** Tokens para servicios de mapa base */
	  var accessTokenMapbox = 'pk.eyJ1IjoiZmpsYWNldmVkbyIsImEiOiJjam9mZm01d2EwM24zM3Fxc3JodHo4bHRoIn0.0j0h7HgZnlj54tesbO9jMA'
	
	  /** Nota indicativa de la arquitectura que se está utilizando */
	  console.log('Ejecutando código de Cesium2D')



	  /** VISOR */

	  /** Se define el visor del mapa, junto a sus propiedades */
	  var viewer = new Cesium.Viewer('mapViewer', {
	    /** Desactiva el widget de la pelota inferior izquierda  */
	    animation: false,
	    /** Botón de inicio */
	    homeButton: false,
	    /** Widget del selector de mapas base */
	    baseLayerPicker: false,
	    /** Botón de pantalla compvara */
	    fullscreenButton: false,
	    /** Cajetín del geocodificador */
	    geocoder: false,
	    /** Botón de ayuda a la navegación */
	    navigationHelpButton: false,
	    /** Botón de selección de modos 2D/2,5D/3D */
	    sceneModePicker: false,
	    /** Widget de la barra temporal inferior */
	    timeline: false,
	    /** Se fuerza el modo en 3D exclusivo */
	    sceneMode: Cesium.SceneMode.SCENE3D,
	    /** Recuadro verde que sale al seleccionar entidades */
	    selectionIndicator: false,
	  })

	  /** Se elimina el mapa base por defecto, y el color azul del fondo */
	  viewer.scene.highDynamicRange = false
	  viewer.scene.imageryLayers.removeAll()
	  viewer.scene.globe.baseColor = Cesium.Color.WHITE



	  /** VARIABLES */

	  var dataSourceCollection = new Cesium.DataSourceCollection()
	  var baseMapsLayers = viewer.imageryLayers
	  var baseMap = null



	  /** FUNCIONES */
	  
	  /** Función que carga un WMS en el mapa */
	  
/** Función que carga servicios WMS en el mapa */
function loadWms(urlWmsService, layers = undefined, layerName) {
	dataSourceLayers.push(layerName);
	/** Se define una variable con el nuevo servicio WMS */
	let wmsService = new Cesium.WebMapServiceImageryProvider({
		url: urlWmsService,
		layers: layers,
		proxy: new Cesium.DefaultProxy('/proxy/'),
		parameters: {
			transparent: true,
			format: 'image/png'
		}
	})

	/** Se define el nombre del servicio, para 'reconocerlo' */
	wmsService.name = 'dataSource' + layerName

	/** Se añade el servicio al visor */
	viewer.imageryLayers.addImageryProvider(wmsService)
}

var heatMapLayers=[];
function heatmapGenerator(jsonData) {
	var layerName = jsonData.name;
	dataSourceLayers.push(layerName);
	/** Se definen los límites del área de estudio */
	let extent = getExtent(jsonData)
	let searchRadius = jsonData.heatMap.radius;
	let min = jsonData.heatMap.min;
	let max = jsonData.heatMap.max;
	/** Se definen las propiedades del mapa de calor */
	let heatmapSetup = {
		radius: searchRadius,
		maxOpacity: 0.6,
		minOpacity: 0.2,
		blur: 0.75
	}

	/** Función que itera el JSON y extrae los datos de coordenadas y valor */
	function getData(values) {
		/** Lista que contendrá las coordenadas y valores de cada punto */
		let data = []

		/** Se itera por cada entidad del JSON */
		for (let feature of values.features) {
			/** Se definen los campos de longitud, latitud y peso */
			let longitude = feature.geometry.coordinates[0]
			let latitude = feature.geometry.coordinates[1]
			let weight = feature.properties.value

			/** Se añade cada campo al listado */
			data.push({ x: longitude, y: latitude, value: weight })
		}

		/** Se devuelve el listado de puntos */
		return data
	}
	
	function getExtent(values) {
		/** Se definen los arrays con los valores de longitud y latitud */
		let longitudeArray = []
		let latitudeArray = []

		/** Se definen las variables con los valores extremos de cada tipo */
		let highestLatitude
		let lowestLatitude
		let highestLongitude
		let lowestLongitude

		/** Se vuelve a iterar por cada entidad del JSON */
		for (let feature of values.features) {
			let longitude = feature.geometry.coordinates[0]
			let latitude = feature.geometry.coordinates[1]

			/** Se añade cada longitud y cada latitud a sus listados */
			longitudeArray.push(longitude)
			latitudeArray.push(latitude)
		}

		/** Se obtienen los valores extremos de longitud */
		highestLongitude = Math.max(...longitudeArray)
		lowestLongitude = Math.min(...longitudeArray)

		/** Se obtienen los valores extremos de latitud */
		highestLatitude = Math.max(...latitudeArray)
		lowestLatitude = Math.min(...latitudeArray)

		/** Se define la extensión del área de estudio */
		let extent = {
			west: lowestLongitude - 0.005,
			south: lowestLatitude - 0.005,
			east: highestLongitude + 0.005,
			north: highestLatitude + 0.005
		}

		/** Se devuelve el extent */
		return extent
	}

	/** Se genera la instancia del mapa de calor */
	let heatMap = CesiumHeatmap.create(viewer, extent, heatmapSetup)

	/** Se añade el mapa de calor al visor */
	heatMap.setWGS84Data(min, max, getData(jsonData))

	heatMapLayers.push({'layer':layerName,'heatMap':heatMap});
	/** Se hace zoom al mapa de calor */
	viewer.flyTo(viewer.entities, {
		offset: new Cesium.HeadingPitchRange(
			Cesium.Math.toRadians(0),
			Cesium.Math.toRadians(-90)
		)
	})
}

function loadKml(urlKml, layerName) {
	dataSourceLayers.push(layerName);
	/** Se genera un dataSource */
	dataSource = new Cesium.KmlDataSource()

	/** Se carga el KML al dataSource */
	dataSource.load(urlKml, {
		camera: viewer.scene.camera,
		canvas: viewer.scene.canvas
	})

	/** Se fuerza el cambio de nombre del dataSource */
	dataSource.name = 'dataSource' + layerName

	/** Se añade el dataSource al visor */
	viewer.dataSources.add(dataSource)

}
	  
/** Función que atiende a la selección de entidades y escucha clicks */
function entityInteractuation() {

  /** Se define una variable que tendrá el elemento seleccionado */
  let selectedEntity

  /** Otra variable con la posición dinámica del punto al moverse */
  let newPosition

  /** Una variable que controla cuando nos estamos moviendo */
  let onMove = false

  /** Se genera un controlador de eventos del visor */
  let handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas)

  /** Esto se ejecutará cuando se haga click con el botón izquierdo */
  handler.setInputAction(function(event){

    /** Si no nos estamos moviendo; es decir, seleccionamos una entidad... */
    if(!onMove) {

      /** Nos aseguramos de que existe una entidad seleccionada  */
      if (viewer._selectedEntity) {

        /** Se mete la entidad seleccionad en la variable */
        selectedEntity = viewer._selectedEntity

        /** Se pasa a desplazamiento */
        onMove = true
      }
    }

    /** ... o si ya está seleccionada una entidad que movemos, entonces... */
    else {

      /** Se recoge la posición del canvas sobre la que se pincha */
      let canvasPosition = new Cesium.Cartesian2(event.position.x, event.position.y)

      /** Se define el elipsoide del mapa */
      let ellipsoid = viewer.scene.globe.ellipsoid

      /** Se transforman las coordenadas del canvas al elipsoide */
      let cartesian = viewer.camera.pickEllipsoid(canvasPosition, ellipsoid)

      /** Se definen las coordenadas de la entidad donde se ha pinchado */
      selectedEntity.position.setValue(cartesian)
      let id= selectedEntity.id;
      /** Se elimina la entidad seleccionada, para volver a empezar */
      selectedEntity = undefined
      
      /** Se llama a la función updateAttribute, dándo la posibilidad de editar los campos*/
      let cartographic = ellipsoid.cartesianToCartographic(cartesian)
      let longitude = Cesium.Math.toDegrees(cartographic.longitude).toFixed(4)
      let latitude = Cesium.Math.toDegrees(cartographic.latitude).toFixed(4)
      editAttribute(null,id, longitude, latitude);

      /** Se pasa a estático */
      onMove = false
    }
  }, Cesium.ScreenSpaceEventType.LEFT_CLICK)

  /** Esto se ejecutará cuando se desplaze el cursor del ratón */
  handler.setInputAction(function(event) {
    
    /** Se comprueba si la entidad seleccionada es correcta */
    if (Cesium.defined(selectedEntity)) {

      /** Se define una nueva posición según donde esté el ratón */
      newPosition = viewer.camera.pickEllipsoid(event.endPosition)
        
      /** Se comprueba si este nuevo punto es válido */
      if (Cesium.defined(newPosition)) {

        /** Se reasignan valores de coordenadas de la entidad seleccionada*/
        selectedEntity.position.setValue(newPosition)
      }
    }
  }, Cesium.ScreenSpaceEventType.MOUSE_MOVE)

  /** Esto se ejecutará cuando se haga click con el botón izquierdo + CONTROL */
  handler.setInputAction(function(click) {

    /** Se define una variable que almacene lo que se pinche */
    let editSelectedEntity = viewer.scene.pick(click.position)

    /** Si se pincha en una entidad */
    if (Cesium.defined(editSelectedEntity)) {

        console.log(editSelectedEntity.primitive)

      /**
       * AQUÍ ES DONDE PUEDES METER TU CÓDIGO. LA ENTIDAD SELECCIONADA ES
       * 'editSelectedEntity', LA CUAL TIENE LA INFORMACIÓN QUE NECESITAS
       * EN LA PROPIEDAD 'primitive'. EL IDENTIFICADOR DE LA ENTIDAD SERÁ
       * 'editSelectedEntity.primitive.id'.
       * 
       * SI PREFIERES QUE SEA CON EL BOTÓN DERECHO EN VEZ DE CON CONTROL +
       * BOTÓN IZQUIERDO, CAMBIA TODA LA LÍNEA DE ABAJO DEL TODO A:
       * 'Cesium.ScreenSpaceEventType.RIGHT_CLICK'
      */

    } 
  }, Cesium.ScreenSpaceEventType.LEFT_CLICK, Cesium.KeyboardEventModifier.CTRL)

}

/** Función que pinta puntos al hacer click en el visor del mapa */
function drawPointClick() {

  /** Variable con la URL de la imagen */
  let imagePoint = 'http://localhost:18000/controlpanel/static/images/viewerIcons/point.png'

  /** El ratón cambia de puntero, para indicar que se puede poner un punto */
  document.body.style.cursor = 'copy'
  
  /** Se define una variable que escuchará los eventos de canvas */
  let handler = new Cesium.ScreenSpaceEventHandler(viewer.canvas)
  
  /** Se producirá este evento cuando se pinche en el visor */
  handler.setInputAction(function(event) {

    /** Se recoge la posición del canvas sobre la que se pincha */
    let canvasPosition = new Cesium.Cartesian2(event.position.x, event.position.y)

    /** Se define el elipsoide del mapa */
    let ellipsoid = viewer.scene.globe.ellipsoid

    /** Se transforman las coordenadas del canvas al elipsoide */
    let cartesian = viewer.camera.pickEllipsoid(canvasPosition, ellipsoid)

    /** Se transforman las coordenadas cartesianas a cartográficas */
    let cartographic = ellipsoid.cartesianToCartographic(cartesian)
    let longitude = Cesium.Math.toDegrees(cartographic.longitude).toFixed(4)
    let latitude = Cesium.Math.toDegrees(cartographic.latitude).toFixed(4)

    /** Se añade un punto en el sitio donde se pincha */
    var id = viewer.entities.add({
		      position : Cesium.Cartesian3.fromDegrees(longitude, latitude),
		      billboard: {
		        image: imagePoint,
		        scale: 1.0,
		      }
		    }).id;
    
    /** Se destruye la variable que escucha, para que pinte un único punto */
    handler.destroy();

    /** El ratón regresa al puntero básico */
    document.body.style.cursor = 'auto'
    
  }, Cesium.ScreenSpaceEventType.LEFT_CLICK)

    /** Se producirá este evento cuando se pinche con el botón derecho */
    handler.setInputAction(function(event) {
      
      /** Se destruye la variable que escucha, para cancelar el evento */
      handler.destroy();
  
      /** El ratón regresa al puntero básico */
      document.body.style.cursor = 'auto'
      
    }, Cesium.ScreenSpaceEventType.RIGHT_CLICK)
}

/** Función que pinta una línea al hacer click en el visor del mapa */
function drawLineClick() {

  /** Se definen las variables a utilizar */
  let colorPoint = Cesium.Color.PINK.withAlpha(0.6)
  let colorPolyline = Cesium.Color.BLUE.withAlpha(0.6)
  let entityCollection = new Cesium.EntityCollection()
  let activeShapePoints = []
  let activeShape
  let floatingPoint
  let handler = new Cesium.ScreenSpaceEventHandler(viewer.canvas)

  /** El ratón cambia de puntero, para indicar que se puede poner un punto */
  document.body.style.cursor = 'copy'
  
  /** Función que genera la entidad de punto */
  function createPoint(pointCoordinates) {
    let point = viewer.entities.add({
      name: 'temporalPoint',
      position : pointCoordinates,
      point : {
        color : colorPoint,
        pixelSize : 6,
      }
    })

    /** Se añade el punto a la colección de puntos, para controlarlo */
    entityCollection.add(point)

    /** Se devuelve el punto, para almacenarlo como punto temporal */
    return point
  }

  /** Función que dibuja la polilínea */
  function drawShapePolyline(positionData) {

    /** Se define una variable con la forma de la entidad */
    let shape
    
    /** Se genera la entidad de la polilínea */
    shape = viewer.entities.add({
      polyline: {
        positions: positionData,
        material: colorPolyline,
        width: 3
      }
    })

    /** Se devuelve la polilínea */
    return shape
  }

  /** Función que genera la polilínea definitiva, eliminando los temporales */
  function generateFinalPolyline() {
    activeShapePoints.pop()
    var id = drawShapePolyline(activeShapePoints).id;
    
     /** Se eliminan las entidades generadas y se vacían las variables */
    viewer.entities.remove(floatingPoint)
    viewer.entities.remove(activeShape)
    floatingPoint = undefined
    activeShape = undefined
    activeShapePoints = []

    /** Se itera por la colección de puntos guía, y se eliminan */
    for (entity of entityCollection.values) {
      viewer.entities.remove(entity)
    }

    /** Se destruye la variable que escucha, para que pinte un único punto */
    handler.destroy()
  
    /** El ratón regresa al puntero básico */
    document.body.style.cursor = 'auto'
}

  /** Se producirá este evento cuando se pinche en el visor */
  handler.setInputAction(function(event) {

    /** Se extraen las coordenadas de donde se pincha con el ratón */
    let position = viewer.camera.pickEllipsoid(event.position)

    /** Se comprueba que donde se pincha está en el mapa */
    if (Cesium.defined(position)) {

      /** Se mira si se han definido puntos activos previamente */
      if (activeShapePoints.length === 0) {

        /** Con cada click, se genera un punto en el mapa */
        floatingPoint = createPoint(position)

        /** Se mete en el listado la posición del punto generado */
        activeShapePoints.push(position)

        /** Se define las posiciones hasta el momento */
        let dynamicPositions = new Cesium.CallbackProperty(function () {
          return activeShapePoints
        }, false)

        /** Se va pintando un polígono temporal con los puntos temporales */
        activeShape = drawShapePolyline(dynamicPositions)
      }
      /** Se van añadiendo al listado las posiciones de los puntos generados */
      activeShapePoints.push(position)

      /** Y se van creando puntos */
      createPoint(position)
    }
  }, Cesium.ScreenSpaceEventType.LEFT_CLICK)

  /** Se producirá este evento cuando se mueva el cursor por el visor */
  handler.setInputAction(function(event) {
    
    /** Se comprueba si el punto flotante es correcto */
    if (Cesium.defined(floatingPoint)) {

      /** Se define una nueva posición (siguinte punto) */
      let newPosition = viewer.camera.pickEllipsoid(event.endPosition)
        
      /** Se comprueba si este nuevo punto es válido */
      if (Cesium.defined(newPosition)) {

        /** Se reasignan valores */
        floatingPoint.position.setValue(newPosition)
        activeShapePoints.pop()
        activeShapePoints.push(newPosition)
      }
    }
  }, Cesium.ScreenSpaceEventType.MOUSE_MOVE)

  /** Cuando el usuario quiera terminar, tocará el botón derecho */
  handler.setInputAction(function(event) {

    /** Se genera la polilínea definitiva */
    generateFinalPolyline()

  }, Cesium.ScreenSpaceEventType.RIGHT_CLICK)
}


/** Función que pinta un polígono al hacer click en el visor del mapa */
function drawPolygonClick() {
  /** Se definen las variables a utilizar */
  let colorPoint = Cesium.Color.PINK.withAlpha(0.6)
  let colorPolygon = Cesium.Color.RED.withAlpha(0.6)
  let entityCollection = new Cesium.EntityCollection()
  let activeShapePoints = []
  let activeShape
  let floatingPoint
  let handler = new Cesium.ScreenSpaceEventHandler(viewer.canvas)

  /** El ratón cambia de puntero, para indicar que se puede poner un punto */
  document.body.style.cursor = 'copy'

  /** Función que generará los puntos guía del polígono */
  function createPoint(pointCoordinates) {
    /** Se genera la entidad de punto */
    let point = viewer.entities.add({
      name: 'temporalPoint',
      position: pointCoordinates,
      point: {
        color: colorPoint,
        pixelSize: 6
      }
    })

    /** Se añade el punto a la colección de entidades, para controlarlo */
    entityCollection.add(point)

    /** Se devuelve el punto, para almacenarlo como punto temporal */
    return point
  }

  /** Función que dibuja el polígono */
  function drawShapePolygon(positionData) {
    /** Se define una variable con la forma de la entidad */
    let shape

    /** Se genera la entidad del polígono */
    shape = viewer.entities.add({
      polygon: {
        hierarchy: positionData,
        material: new Cesium.ColorMaterialProperty(colorPolygon)
      }
    })

    /** Se devuelve la forma del polígono */
    return shape
  }

  /** Función que genera el polígono definitivo, eliminando los temporales */
  function generateFinalPolygon() {
    activeShapePoints.pop()
    drawShapePolygon(activeShapePoints)

    /** Se eliminan las entidades generadas y se vacían las variables */
    viewer.entities.remove(floatingPoint)
    viewer.entities.remove(activeShape)
    floatingPoint = undefined
    activeShape = undefined
    activeShapePoints = []

    /** Se itera por la colección de puntos guía, y se eliminan */
    for (entity of entityCollection.values) {
      viewer.entities.remove(entity)
    }

    /** Se destruye la variable que escucha */
    handler.destroy()

    /** El ratón regresa al puntero básico */
    document.body.style.cursor = 'auto'
  }

  /** Se producirá este evento cuando se pinche en el visor */
  handler.setInputAction(function(event) {
    /** Se extraen las coordenadas de donde se pincha con el ratón */
    let position = viewer.camera.pickEllipsoid(event.position)

    /** Se comprueba que donde se pincha está en el mapa */
    if (Cesium.defined(position)) {
      /** Se mira si se han definido puntos activos previamente */
      if (activeShapePoints.length === 0) {
        /** Con cada click, se genera un punto en el mapa */
        floatingPoint = createPoint(position)

        /** Se mete en el listado la posición del punto generado */
        activeShapePoints.push(position)

        /** Se define las posiciones hasta el momento */
        let dynamicPositions = new Cesium.CallbackProperty(function() {
          return activeShapePoints
        }, false)

        /** Se va pintando un polígono temporal con los puntos temporales */
        activeShape = drawShapePolygon(dynamicPositions)
      }

      /** Se van añadiendo al listado las posiciones de los puntos generados */
      activeShapePoints.push(position)

      /** Y se van creando puntos */
      createPoint(position)
    }
  }, Cesium.ScreenSpaceEventType.LEFT_CLICK)

  /** Se producirá este evento cuando se mueva el cursor por el visor */
  handler.setInputAction(function(event) {
    /** Se comprueba si el punto flotante es correcto */
    if (Cesium.defined(floatingPoint)) {
      /** Se define una nueva posición (siguinte punto) */
      let newPosition = viewer.camera.pickEllipsoid(event.endPosition)

      /** Se comprueba si este nuevo punto es válido */
      if (Cesium.defined(newPosition)) {
        /** Se reasignan los valores */
        floatingPoint.position.setValue(newPosition)
        activeShapePoints.pop()
        activeShapePoints.push(newPosition)
      }
    }
  }, Cesium.ScreenSpaceEventType.MOUSE_MOVE)

  /** Cuando el usuario quiera terminar, tocará el botón derecho */
  handler.setInputAction(function(event) {
    /** Se genera la polilínea definitiva */
    generateFinalPolygon()
  }, Cesium.ScreenSpaceEventType.RIGHT_CLICK)
}

/** Función que pinta dibuja polígonos a mano alzada en el visor del mapa */
function drawPolygonFreehand() {
  /** Se definen las variables a utilizar */
  let colorPolygon = Cesium.Color.fromCssColorString('#FF0000').withAlpha(0.6)
  let drawing = false
  let polyline
  let positions = []
  let handler = new Cesium.ScreenSpaceEventHandler(viewer.canvas)

  /** El ratón cambia de puntero, para indicar que se puede poner un punto */
  document.body.style.cursor = 'copy'

  /** Se producirá este evento cuando se pinche en el visor */
  handler.setInputAction(function(click) {
    /** En caso de que no exista ningún polígono (primer uso) */
    if (!drawing) {
      /** Se define la polilínea siguiendo al puntero del ratón */
      polyline = viewer.entities.add({
        polyline: {
          positions: new Cesium.CallbackProperty(function() {
            return positions
          }, false),
          material: colorPolygon
        }
      })

      /** Cuando se haya pintado el polígono que interesa */
    } else {
      /** Se define el polígono a partir de la polilínea */
      viewer.entities.add({
        polygon: {
          hierarchy: {
            positions: positions
          },
          material: colorPolygon,
          outline: true
        }
      })

      /** Se borra la polilínea generada durante el pintado */
      viewer.entities.remove(polyline)

      /** Se limpia el array de coordenadas usado por la polilínea */
      positions = []

      /** Se destruye la variable que escucha, para que pinte un único
       * polígono */
      handler.destroy()

      /** El ratón regresa al puntero básico */
      document.body.style.cursor = 'auto'
    }

    /** No hay verdad sin falsedad */
    drawing = !drawing
  }, Cesium.ScreenSpaceEventType.LEFT_CLICK)

  /** Por si se usa el botón derecho para cerrar el polígono */
  handler.setInputAction(function(click) {
    viewer.entities.add({
      polygon: {
        hierarchy: {
          positions: positions
        },
        material: colorPolygon,
        outline: true
      }
    })

    /** Se borra la polilínea generada durante el pintado */
    viewer.entities.remove(polyline)

    /** Se limpia el array de coordenadas usado por la polilínea */
    positions = []

    /** Se destruye la variable que escucha, para que pinte un único
     * polígono */
    handler.destroy()

    /** El ratón regresa al puntero básico */
    document.body.style.cursor = 'auto'
  }, Cesium.ScreenSpaceEventType.RIGHT_CLICK)

  /** Se producirá este evento cuando se mueva el puntero por el visor */
  handler.setInputAction(function(movement) {
    /** Se define una variable con el punto final del movimiento */
    let surfacePosition = viewer.camera.pickEllipsoid(movement.endPosition)

    /** En caso de que exista el dibujo del polígono y su punto final */
    if (drawing && Cesium.defined(surfacePosition)) {
      /** Se añade al listado de posiciones el punto final del movimiento */
      positions.push(surfacePosition)
    }
  }, Cesium.ScreenSpaceEventType.MOUSE_MOVE)
}


/** Función que limpia TODO lo que se dibuje en el mapa */
function clearEntities() {
  viewer.entities.removeAll()
}

/** Función que saca una regla de medida en el visor
 * TODO: hay que hacer la etiqueta de medida dinámica (fjla)
 */
function measureRuler() {

  /** Se definen las variables a utilizar */
  let colorPoint = Cesium.Color.BROWN.withAlpha(0.6)
  let colorPolyline = Cesium.Color.DARKORANGE.withAlpha(0.6)
  let entityCollection = new Cesium.EntityCollection()
  let activeShapePoints = []
  let activeShape
  let floatingPoint
  let handler = new Cesium.ScreenSpaceEventHandler(viewer.canvas)
  let counter = 0

  /** Se comprueba si existe una 'regla' previa, y si es así la elimina */
  for (entity of viewer.entities.values) {
    if (entity.name === "measurePolyline") {
      viewer.entities.remove(entity)
    }
  }

  /** Se comprueba si existe un etiquetado previo, y dado el caso lo elimina
   * Esto se mete por separado porque en el mismo FOR peta */
  for (entity of viewer.entities.values) {
    if (entity.name === "measureLabel") {
      viewer.entities.remove(entity)
    }
  }

  /** El ratón cambia de puntero, para indicar que se puede poner un punto */
  document.body.style.cursor = 'copy'
  
  /** Se genera la entidad de punto */
  function createPoint(pointCoordinates) {
    let point = viewer.entities.add({
      name: 'temporalPoint',
      position : pointCoordinates,
      point : {
        color : colorPoint,
        pixelSize : 6,
      }
    })

    /** Se añade el punto a la colección de puntos, para controlarlo */
    entityCollection.add(point)

    /** Se devuelve el punto, para almacenarlo como punto temporal */
    return point
  }

  /** Función que dibuja la polilínea */
  function drawShapePolyline(positionData) {

    /** Se define una variable con la forma de la entidad */
    let shape
    
    /** Se genera la entidad de la polilínea */
    shape = viewer.entities.add({
      name: "measurePolyline",
      polyline: {
        positions: positionData,
        material : new Cesium.PolylineDashMaterialProperty({
          color : colorPolyline,
          dashLength: 12.0
        }),
        width: 3
      }
    })

    /** Se devuelve la polilínea */
    return shape
  }

  /** Función que calcula la longitud de la polilínea */
  function polylineLength(polyline) {

    /** Se definen los puntos iniciales y finales de la polilínea */
    let initialPosition = polyline.polyline.positions.getValue()[0]
    let finalPosition = polyline.polyline.positions.getValue()
    [polyline.polyline.positions.getValue().length - 1]
    
    /** Se genera el elipsoide geodésico a partir de las coordenadas */
    let ellipsoidGeodesic = new Cesium.EllipsoidGeodesic(
      Cesium.Ellipsoid.WGS84.cartesianToCartographic(initialPosition),
      Cesium.Ellipsoid.WGS84.cartesianToCartographic(finalPosition))

    let midPoint = ellipsoidGeodesic.interpolateUsingFraction(0.5)
    
    /** Se define la etiqueta que aparecerá encima de la regla */
    viewer.entities.add({
      name: 'measureLabel',
      position : new Cesium.Cartesian3.fromRadians(
        midPoint.longitude,
        midPoint.latitude,
        midPoint.height),
      label : {
        text: (ellipsoidGeodesic.surfaceDistance * 0.001).toFixed(2) + 'km',
        style: Cesium.LabelStyle.FILL_AND_OUTLINE,
        outlineWidth : 2,
        font : '18px sans-serif',
        pixelOffset : new Cesium.Cartesian2(0.0, -20)
      }
    })

    //entityCollection.add(measureLabel)
  }

  /** Función que elimina los puntos de guiado de la guía */
  function clear() {

    /** Se itera por la colección de puntos guía, y se eliminan */
    for (entity of entityCollection.values) {
      viewer.entities.remove(entity)
    }
  }


  /** Se producirá este evento cuando se pinche en el visor */
  handler.setInputAction(function(event) {

    /** Se saca la posición respecto al elipsoide */
    let position = viewer.camera.pickEllipsoid(event.position)

    /** Se comprueba que donde se pincha está en el mapa */
    if (Cesium.defined(position)) {

      /** Se indica el número de puntos generados hasta el momento */
      counter += 1

      /** Se mira si se han definido puntos activos previamente */
      if (activeShapePoints.length === 0) {

        /** Con cada click, se genera un punto en el mapa */
        floatingPoint = createPoint(position)

        /** Se mete en el listado la posición del punto generado */
        activeShapePoints.push(position)

        /** Se define las posiciones hasta el momento */
        let dynamicPositions = new Cesium.CallbackProperty(function () {
          return activeShapePoints
        }, false)

        /** Se va pintando un polígono temporal con los puntos temporales */
        activeShape = drawShapePolyline(dynamicPositions)
      }

      /** Se van añadiendo al listado las posiciones de los puntos generados */
      activeShapePoints.push(position)

      /** Y se van creando puntos */
      createPoint(position)

      /** Se cuenta si hay al menos dos puntos ya pintados */
      if (counter >1) {

        /** Entonces se lanza la función que mide entre puntos */
        polylineLength(activeShape)

        /** Se destruye la variable que escucha, para que pinte un único punto */
        handler.destroy()

        /** Se limpia */
        clear()
      
        /** El ratón regresa al puntero básico */
        document.body.style.cursor = 'auto'
      }
    }
  }, Cesium.ScreenSpaceEventType.LEFT_CLICK)

  /** Se producirá este evento cuando se mueva el cursor por el visor */
  handler.setInputAction(function(event) {

    /** Se comprueba si el punto flotante es correcto */
    if (Cesium.defined(floatingPoint)) {

      /** Se define una nueva posición (siguinte punto) */
      let newPosition = viewer.camera.pickEllipsoid(event.endPosition)

      /** Se comprueba si este nuevo punto es válido */
      if (Cesium.defined(newPosition)) {

        /** Se reasignan los valores */
        floatingPoint.position.setValue(newPosition)
        activeShapePoints.pop()
        activeShapePoints.push(newPosition)
        }
      }
  }, Cesium.ScreenSpaceEventType.MOUSE_MOVE)

  /** Cuando el usuario quiera terminar, tocará el botón derecho */
  handler.setInputAction(function(event) {

    /** Se indica el número de puntos generados hasta el momento */
    counter += 1

    if (counter >1) {
      /** Se lanza la función que mide entre puntos */
      polylineLength(activeShape)
      clear()
    }

    /** Se destruye la variable que escucha, para que pinte un único punto */
    handler.destroy()
  
    /** El ratón regresa al puntero básico */
    document.body.style.cursor = 'auto'

  }, Cesium.ScreenSpaceEventType.RIGHT_CLICK)
}

	  /** Función que define la extensión inicial del mapa */
	  function defineViewerInitialExtent(longitude,latitude,altitud) {
	    viewer.camera.setView({
	      destination : Cesium.Cartesian3.fromDegrees(longitude, latitude, altitud)
	    })
	  }

	  /** Función que define el mapa base de inicio */
	  function initialBaseMap(nameBaseMap, accessToken = '', urlBase) {
		/** Se clasifica el tipo de mapa base a utilizar */
		  baseMapType = nameBaseMap.split('.')[0]
		  baseMapName = nameBaseMap.split('.')[1]
		  baseMapStyle = nameBaseMap.split('.')[2]
		  
		  /** Variable que hará referencia a la variable con la URL del mapa base */
		  let urlBaseMap = null
		
		  /** Se comprueba si el mapa base es de CartoDB */
		  if (baseMapType === 'cartodb') {
		
		    /** Se comprueba si el mapa será sin etiquetas */
		    if (baseMapStyle === 'NoLabels') {
		
		      if (baseMapName === 'Positron') {
		        urlBaseMap = urlBase
		      }
		
		      else if (baseMapName === 'DarkMatter') {
		        urlBaseMap = urlBase
		      }
		
		      else if (baseMapName === 'Voyager') {
		        urlBaseMap = urlBase
		      }
		    }
		
		    /** Se comprueba si el mapa será con etiquetas */
		    else if (baseMapStyle === 'Labels') {
		
		      if (baseMapName === 'Positron') {
		        urlBaseMap = urlBase
		      }
		
		      else if (baseMapName === 'DarkMatter') {
		        urlBaseMap = urlBase
		      }
		
		      else if (baseMapName === 'Voyager') {
		        urlBaseMap = urlBase
		      }
		    }
		
		    /** Se comprueba si el mapa será únicamente de etiquetas */
		    else if (baseMapStyle === 'OnlyLabels') {
		
		      if (baseMapName === 'Positron') {
		        urlBaseMap = urlBase
		      }
		
		      else if (baseMapName === 'DarkMatter') {
		        urlBaseMap = urlBase
		      }
		
		      else if (baseMapName === 'Voyager') {
		        urlBaseMap = urlBase
		      }
		    }
		
		    /** Se añade el mapa base al mapa */
		    baseMap = baseMapsLayers.addImageryProvider(new Cesium.UrlTemplateImageryProvider({
		      url : urlBaseMap,
		    }))
		  }
		
		  /** Se comprueba si el mapa base es de CartoDB */
		  else if (baseMapType === 'esri') {
		
		    /** Se comprueba si se está cargando un mapa base sin etiquetado */
		    if (baseMapStyle === 'NoLabels') {
		
		      if (baseMapName === 'DarkGray') {
		        urlBaseMap = urlBase
		      }
		
		      else if (baseMapName === 'Gray') {
		        urlBaseMap = urlBase
		      }
		
		      else if (baseMapName === 'Imagery') {
		        urlBaseMap = urlBase
		      }
		
		      else if (baseMapName === 'ShadedRelief') {
		        urlBaseMap = urlBase
		      }
		
		      /** Se añade el mapa base */
		      baseMap = baseMapsLayers.addImageryProvider(new Cesium.ArcGisMapServerImageryProvider({
		        url : urlBaseMap,
		      }))
		    }
		    
		    /** Se comprueba si se está cargando un mapa base con etiquetado */
		    else if (baseMapStyle === 'Labels') {
		
		      if (baseMapName === 'DarkGray') {
		        baseMap = baseMapsLayers.addImageryProvider(new Cesium.ArcGisMapServerImageryProvider({
		          url : urlBase
		        }))
		                    
		        baseMap = baseMapsLayers.addImageryProvider(new Cesium.ArcGisMapServerImageryProvider({
		          url : urlBase,
		        }))
		      }
		
		      else if (baseMapName === 'Gray') {
		        baseMap = baseMapsLayers.addImageryProvider(new Cesium.ArcGisMapServerImageryProvider({
		          url : urlBase
		        }))
		                    
		        baseMap = baseMapsLayers.addImageryProvider(new Cesium.ArcGisMapServerImageryProvider({
		          url : urlBase,
		        }))
		      }
		
		      else if (baseMapName === 'Imagery') {
		        baseMap = baseMapsLayers.addImageryProvider(new Cesium.ArcGisMapServerImageryProvider({
		          url : urlBase
		        }))
		                    
		        baseMap = baseMapsLayers.addImageryProvider(new Cesium.ArcGisMapServerImageryProvider({
		          url : urlBase,
		        }))
		      }
		
		      else if (baseMapName === 'ShadedRelief') {
		        baseMap = baseMapsLayers.addImageryProvider(new Cesium.ArcGisMapServerImageryProvider({
		          url : urlBase
		        }))
		                    
		        baseMap = baseMapsLayers.addImageryProvider(new Cesium.ArcGisMapServerImageryProvider({
		          url : urlBase,
		        }))
		      }
		
		      else if (baseMapName === 'Streets') {
		        baseMap = baseMapsLayers.addImageryProvider(new Cesium.ArcGisMapServerImageryProvider({
		          url : urlBase
		        }))
		      }
		
		      else if (baseMapName === 'Topo') {
		        baseMap = baseMapsLayers.addImageryProvider(new Cesium.ArcGisMapServerImageryProvider({
		          url : urlBase
		         }))
		      }
		    }
		    
		    /** Se comprueba si se está cargando un mapa base sólo de etiquetado */
		    else if (baseMapStyle === 'OnlyLabels') {
		
		      if (baseMapName === 'DarkGray') {
		        urlBaseMap = urlBase
		      }
		
		      else if (baseMapName === 'Gray') {
		        urlBaseMap = urlBase
		      }
		
		      else if (baseMapName === 'Reference') {
		        urlBaseMap = urlBase
		      }
		
		      /** Se añade el mapa base */
		      baseMap = baseMapsLayers.addImageryProvider(new Cesium.ArcGisMapServerImageryProvider({
		        url : urlBaseMap,
		      }))
		    }
		  }
		
		  /** Se comprueba si el mapa base es de OSM */
		  else if (baseMapType === 'osm') {
		
		    /** Se comprueba si se está cargando un mapa base sin etiquetado */
		    if (baseMapStyle === 'NoLabels') {}
		
		    /** Se comprueba si se está cargando un mapa base con etiquetado */
		    else if (baseMapStyle === 'Labels') {
		
		      if (baseMapName === 'Mapnik') {
		        baseMap = baseMapsLayers.addImageryProvider(Cesium.createOpenStreetMapImageryProvider({
		          url: urlBase,
		        }))
		      }
		
		      else if (baseMapName === 'BlackAndWhite') {
		        baseMap = baseMapsLayers.addImageryProvider(new Cesium.UrlTemplateImageryProvider({
		          url : urlBase,
		        }))
		      }
		    }
		
		    /** Se comprueba si se está cargando un mapa base sólo de etiquetado */
		    else if (baseMapStyle === 'OnlyLabels') {}
		  }
		
		  /** Se comprueba si el mapa base es de OSM */
		  else if (baseMapType === 'mapbox') {
		    let mapId = null
		
		    /** Se comprueba si se está cargando un mapa base sin etiquetado */
		    if (baseMapStyle === 'NoLabels') {
		
		      if (baseMapName === 'Satellite') {
		        mapId = 'mapbox.satellite'
		      }
		
		      else if (baseMapName === 'Outdoors') {
		        mapId = 'mapbox.outdoors'
		      }
		
		      else if (baseMapName === 'Pencil') {
		        mapId = 'mapbox.pencil'
		      }
		    }
		
		    /** Se comprueba si se está cargando un mapa base con etiquetado */
		    else if (baseMapStyle === 'Labels') {
		
		      if (baseMapName === 'Streets') {
		        mapId = 'mapbox.streets'
		      }
		
		      else if (baseMapName === 'Light') {
		        mapId = 'mapbox.light'
		      }
		
		      else if (baseMapName === 'Dark') {
		        mapId = 'mapbox.dark'
		      }
		
		      else if (baseMapName === 'Pirates') {
		        mapId = 'mapbox.pirates'
		      }
		
		      else if (baseMapName === 'Comic') {
		        mapId = 'mapbox.comic'
		      }
		
		      else if (baseMapName === 'Emerald') {
		        mapId = 'mapbox.emerald'
		      }
		    }
		
		    /** Se comprueba si se está cargando un mapa base sólo de etiquetado */
		    else if (baseMapStyle === 'OnlyLabels') {}
		
		    baseMap = baseMapsLayers.addImageryProvider(new Cesium.MapboxImageryProvider({
		      mapId: mapId,
		      accessToken: accessToken
		    }))
		  }
	  }
	  
	  /** Función que muestra las coordenadas del ratón */
function showMouseCartographicPosition() {

  /** Se genera la escucha del canvas */
  let handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas)
  
  /** Se genera una entidad 'invisible' que seguirá al ratón */
  let fakeEntity = viewer.entities.add({
    label : {
        show : false,
        showBackground : true,
        font : '14px monospace',
        horizontalOrigin : Cesium.HorizontalOrigin.LEFT,
        verticalOrigin : Cesium.VerticalOrigin.TOP,
        pixelOffset : new Cesium.Cartesian2(15, 0)
    }
  })

  /** Se producirá este evento cuando se mueva el cursor por el visor */
  handler.setInputAction(function(movement) {
    let cartesian = viewer.camera.pickEllipsoid(movement.endPosition, viewer.scene.globe.ellipsoid)
    if (cartesian) {
      let cartographic = Cesium.Cartographic.fromCartesian(cartesian)

      /** Se define la longitud y latitud, limitando los decimales a un par */
      let longitudeString = Cesium.Math.toDegrees(cartographic.longitude).toFixed(2)
      let latitudeString = Cesium.Math.toDegrees(cartographic.latitude).toFixed(2)

      /** Se obtienen las coordenadas de la falsa entidad */
      fakeEntity.position = cartesian
      fakeEntity.label.show = true

      /** Se incluye el texto de la ventanita de las coordenadas. */
      fakeEntity.label.text =
        'Longitude: ' + ('   ' + longitudeString).slice(-7) + '\u00B0' +
        'Latitude: ' + ('   ' + latitudeString).slice(-7) + '\u00B0'
    } else {
        fakeEntity.label.show = false
    }
  }, Cesium.ScreenSpaceEventType.MOUSE_MOVE)

}

		  /** Función que genera capas en el mapa */
	  function createLayer(layer) {
		var layerName = layer.name
		dataSourceLayers.push(layerName);
	 	/** Variable con el nombre de la capa, definido en el objeto JSON */
			    
		
			    /** Se genera un nombre propio para el dataSource */
			    var dataSourceName = 'dataSource' + layerName
		
			    /** Se comprueba si la capa es de tipo punto */
			    if (layer.typeGeometry === 'Point') {
		
			        /** Se genera un array con las entidades a representar */
			      var entities = []
			      entities = layer.features
		
			      /** Se comprueba que no haya otro dataSource existente con el mismo nombre
			       * TO-DO: dataSourceCollection.contains(dataSourceName) */
		
			      /** Se crea el dataSource personalizado, con su nombre propio */
			      var dataSource = new Cesium.CustomDataSource({
			        name: dataSourceName
			      })
		
			      /** Se mete el dataSource creado en la colección de dataSources */
			      dataSourceCollection.add(dataSourceName)
		
			      /** Se itera por las entidades, y se meten en el dataSource
			       * TO-DO: parsear TODOS los campos de la ontología --> pendiente de conocerlos */
			      for (var entity of entities){
			        /** Variables con las propiedades de la entidad */
			        var entityId = entity.properties.id
			        var entityName = entity.properties.name
		
			        /** Variables con la longitud y latitud de la entidad */
			        var longitude = entity.geometry.coordinates[0]
			        var latitude = entity.geometry.coordinates[1]
		
			        /** Se comprueba si se va a simbolizar con un punto básico */
			        if (layer.symbology.name === 'simbPointBasic') {
			          /** Se rellenan las variables */
			          var pixelSize = layer.symbology.pixelSize
			          var innerColorTransformacion = new Cesium.Color.fromBytes(layer.symbology.innerColorRGB.red,layer.symbology.innerColorRGB.green,layer.symbology.innerColorRGB.blue)
			          var innerColor = new Cesium.Color.fromAlpha(innerColorTransformacion,layer.symbology.innerColorAlpha)
			          var outlineColorTransformacion = new Cesium.Color.fromBytes(layer.symbology.outlineColorRGB.red,layer.symbology.outlineColorRGB.green,layer.symbology.outlineColorRGB.blue)
			          var outlineColor = new Cesium.Color.fromAlpha(outlineColorTransformacion,layer.symbology.outlineWidthAlpha)
			          var outlineWidth = layer.symbology.outlineWidth
		
		
			          /** Se añade la entidad al dataSource, con las siguientes propiedades */
			          dataSource.entities.add({
			            id: entityId,
			            name: entityName,
			            position: Cesium.Cartesian3.fromDegrees(longitude, latitude),
			            point : {
			              color : innerColor,
			              pixelSize : pixelSize,
			              outlineColor : outlineColor,
			              outlineWidth : outlineWidth
			            }
			          })
			        }
		
			        /** En caso de que se vaya a simbolizar con una imagen */
			        else if (layer.symbology.name === 'simbPointBillboard') {
			          /** Se rellenan las variables */
			          var image = layer.symbology.image
			          var scale = layer.symbology.scale
		
			          /** Se añade la entidad al dataSource, con las siguientes propiedades */
			          dataSource.entities.add({
			            id: entityId,
			            name: entityName,
			            position: Cesium.Cartesian3.fromDegrees(longitude, latitude),
			            billboard: {
			              image: image,
			              scale: scale,
			            }
			          })
			        }
			      }
		
			      /** Se añade el dataSource al visor, mostrando la capa */
			      viewer.dataSources.add(dataSource)
			    }
		
			    /** Se comprueba si la capa es de tipo línea */
			    else if (layer.typeGeometry === 'Polyline') {
		
			      /** Se crea el dataSource personalizado, con su nombre propio */
			      var dataSource = new Cesium.GeoJsonDataSource({
			        name: dataSourceName
			      })
		
			      /** Se mete el dataSource creado en la colección de dataSources */
			      dataSourceCollection.add(dataSource)
		
			      /** Se preparan las variables de la simbología */
			      var innerColorTransformacion = new Cesium.Color.fromBytes(layer.symbology.innerColorRGB.red,layer.symbology.innerColorRGB.green,layer.symbology.innerColorRGB.blue)
			      var innerColor = new Cesium.Color.fromAlpha(innerColorTransformacion,layer.symbology.innerColorAlpha)
			      var strokeWidth = layer.symbology.strokeWidth
		
			      /** Se añaden las entidades al dataSource automáticamente, con la siguiente
			       * configuración de simbología */
			      dataSource.load(layer, {
			        stroke: innerColor,
			        strokeWidth: strokeWidth
			      })
			      /** Se añade el dataSource al visor, mostrando la capa */
			      viewer.dataSources.add(dataSource)
			    }
		
			      /** Se comprueba si la capa es de tipo línea */
			    else if (layer.typeGeometry === 'Polygon') {
		
			      /** Se crea el dataSource personalizado, con su nombre propio */
			      var dataSource = new Cesium.GeoJsonDataSource({
			        name: dataSourceName
			      })
		
			      /** Se mete el dataSource creado en la colección de dataSources */
			      dataSourceCollection.add(dataSource)
		
			      /** Se preparan las variables de la simbología */
			      var innerColorTransformacion = new Cesium.Color.fromBytes(layer.symbology.innerColorRGB.red,layer.symbology.innerColorRGB.green,layer.symbology.innerColorRGB.blue)
			      var innerColor = new Cesium.Color.fromAlpha(innerColorTransformacion,layer.symbology.innerColorAlpha)
			      var outlineColorTransformacion = new Cesium.Color.fromBytes(layer.symbology.outlineColorRGB.red,layer.symbology.outlineColorRGB.green,layer.symbology.outlineColorRGB.blue)
			      var outlineColor = new Cesium.Color.fromAlpha(outlineColorTransformacion,layer.symbology.outerColorAlpha)
			      var outlineWidth = layer.symbology.outlineWidth
		
			      /** Se añaden las entidades al dataSource automáticamente, con la siguiente
			       * configuración de simbología */
			      dataSource.load(layer, {
			        fill: innerColor,
			        stroke: outlineColor,
			        strokeWidth: outlineWidth
			      })
		
			      /** Se añade el dataSource al visor, mostrando la capa */
			      viewer.dataSources.add(dataSource)
			    }
		
			    /** En caso de que no se haya definido una geometría, por la razón que sea,
			     * se avisa con un registro en la consola.
			     */
			    else {
			      console.log('La ontología ' + layerName + ' carece de geometría ' + 
			      ' definida, por lo que no se representará. Por favor, comprobar ' +
			      'el archivo fuente.')
			    }

	  }



	  /** EJECUCIONES */

	  defineViewerInitialExtent(initialLongitude,initialLatitude,initialHeight)

